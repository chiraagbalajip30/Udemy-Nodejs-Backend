Video - 29

HTTP - Hypertext Transfer Protocol - A protocol to transfer information on the internet.

There will be a client and a server. 
Server is just a machine connected to the internet, which has a public ip adress and it has a public facing IP adress.
Server is 24/7 on time, and has public faing static ip. Example ip - 10.24.1.2

What happens is client sends a reqwuest to a server asking something or uploading something or loading something, etc. So before this, Authentication must be happened - like if this particulkar user is allowed to access. Then Authorization, then Validation and then the request will be Processed.

Then Server will be connected to the Database(Postgres/Mongo/Mysql).

Once the Srver has done it's work, it returns something known as Response. 

This is what is known as Request-Response Cycle.



Video - 30
-------------


HTTP Methods - GET, POST, PUT, PATCH, DELETE
HTTP Status Codes - (404 Not Found), etc.


HTTP METHODS.
---------------
WHen the client sends a request, this request has somnething known as http method. Ex: rewquest can be of get type, post type, delete type, etc. IN order for client to get some work don, he must send a http request.

GET - See all the tweets, watch a video, etc.
POST - ccreate a tweet, upload a video, etc.
PATCH - When client wants to update some existing data.
DELETE - When client wants to delete some data.


HTTP RESPONSE METHODS.
------------------------

WHen you send a request, the server sends a status code along with the request. Status codes are just a bunch of codes.


200 - Ok 
201 - Ok and created
301 - Redirect
400 - Bad Request
401 - Unauthorized
404 - Not Found
500 - Internal Server Error

Status Codes are ytou to tell what kind of response it is (Success, Error, Redirect, etc).


From MDN docs: (https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status)
Informational responses (100 – 199)
Successful responses (200 – 299)
Redirection messages (300 – 399)
Client error responses (400 – 499)
Server error responses (500 – 599)




Video - 31
--------------

We will start with practical and build our very first server.


He installed dependancies again. I have used this in the beginning sdtages of the video but i will write this down again.
open terminal and write "npm init" and you will get some questions. 
To skip those questions, you can write "npm init -y".
Later, to install the dependancies, "npm i @types/node".

In order to create a server, we have to use a built-in server called "http".

while you create serve using createServer method, you wll hjave req and res objects.
Req is what user is trying to access(get, post, patch method). So, what user is trying to access will be available in this req object.
Res obj is used to construct a response.


const server = http.createServer(function (req, res) {
  console.log("I got an incoming request");
});

server.listen(8000, () => {
  console.log("Listening on port 8000");
});


Hetre, youu are never sending a response(console.log is just a log statement not a response).
So what happens is when you try to oepn the port 8000 by typing localhost:8000, the site will be struck forever.

const server = http.createServer(function (req, res) {
  console.log("I got an incoming request");
  // insteasd of console, you can do db operastins, etc.
  res.writeHead(200);
  res.end("Thanks for visitng my server");
});

Now we have sent a respoonse. 
res.writeHead(200, {'Content-Type': 'application/json'});  This is the actual line in docs.
Here we have just shortebned and used it.


Now i the above code, when you open that port 8000, you will get that console.log statement stating "Thanks for visiting kmy serve" or something.


WHat is a Port?
Let us say we have a physical machine (server).
Say physical machine will be having a address like 10.2.3.4. Physical machine is like a hoiuse. We can have multiple servivces running, and they can lsiten on a specific port. Let us say, one service is listening on port 2000, another one on 8000, ect. Only one service can listen to a port at a time. 
If i am a user, on this machine, we say to 10.2.3.4:3000. Means inside this meachine or server, go to this port 3000.

Rule - Only one service per port.


const http = require("node:http");

const server = http.createServer(function (req, res) {
  console.log("I got an incoming request");
  // insteasd of console, you can do db operastins, etc.
  res.writeHead(200);
  res.end("Thanks for visitng my server");
});

// server.listen(8000, function() {
//     console.log('Listening on port 8000');
// }) or we can use arrow functions

server.listen(8000, () => {
  console.log("Listening on port 8000");
});

FInal Code of Video-31  -  Creating basic HTTP Server with core Node.js Modules










Video - 32
------------
HTTP Request Handling and Server Routing


Whwenever you are sending a request, you have to specify what Method it is(GET, etc), and for every request you can send extra piece of data known as HEADER. They will be stored in the form of key:value pair. These are jsut an extra info sent along with the request.
Example:
Headers {
    'Content-Type': 'application/json',
    'Authorization': 'TOKEN'
}

Server can read these headers and process the request based on this context. 

We can also add some extra info in the header like userName: 'mcb'.

It cxan also have an body which is optional thing.
For example, when you're making a post request, you must include the body.
The body of an HTTP request contains any info being submitted to the web server, such as username and password, or any other data entered into a form.


https://www.google.com/contact-us?q=xyz&sort=desc
Here, 
https - Scheme
www - subdomain
google.com - NAKED OR aPEX OR oRIGINAL dOMAIN
contact-us - path

q=xyz&sort=desc - Query Paramters(anything after question mark). These are some extra key-value pairs which can be sent along with the url.
now we have two query poarameters.
q=xyz and sort=desc


Now, this part that is, www.google.com is for dns purpose that is it helps us reach properly to the server. Then after that part the remaining part, it is processed by the server to decide what info to provide based on thge path and query paramaters.

ALl these we saw was just about what Request looks like, not the response.



-----------------------------------------------


Video - 33
---------
Building a custom Server with Node.js - Hands one


Insstead of writing node file_name in the terminal again and agai, you ccan go to the package.json, and edit the scripts. You remove the exisitng one inside scripts, and write: start: "node index.js".
Then when you want to run from the next time, write npm start.

{
  "name": "http-server",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node --watch index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@types/node": "^25.2.1"
  }
}

Now, if I add --watch after node, it ewill keep watching the server again and again, and there will be no need to run the commad again.



fetch('/', {method: 'POST'})
you can add this in the console.log(for now because there is ot frontend, and post request must be made frontend) and get POST request in the backend.



I have written in the code how to play with routes using switch case using node.js in index.js file.
