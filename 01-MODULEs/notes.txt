Video - 19 and 20
-------------------

Related code in index.js File

MODULES - It is a collection of code, that provides your functionality. There are 3 types:

1. Built In Modules
2. Third Party or External Modules - which can be installed using npm intall
3. Custom Modules (my own)

Built In Modules
--------------------
File System Module (fs)

was given beacuse nodejs is a js built into c program, they have given whole fs modules, which helps us to work onnode modules in the machine.

if you want to read the files, use readFileSync. You have to add the binary code format like utf-8 to see the content properly

fs.readFileSync() is a method from Node.js's built-in fs (File System) module. "It reads the entire contents of a file from your disk synchronously" (meaning it blocks / pauses your entire program until the reading is finished).

These below sync and async haven't be thought yet

Use Sync (...Sync): Quick scripts, config loading at startup, learning, build tools, when order matters and you don't mind blocking
Use Async/Promises: Servers, APIs, apps that handle many requests â€” never block the event loop!



Operation,Synchronous (blocking),Asynchronous Callback,Promise / async-await (best in 2026),What it does
Read whole file,"fs.readFileSync(path, [options])","fs.readFile(path, options, callback)","fsPromises.readFile(path, options)",Read entire file content
Write / overwrite file,"fs.writeFileSync(file, data, [options])","fs.writeFile(file, data, options, cb)","fsPromises.writeFile(file, data, options)",Create or replace file with new content
Append to file,"fs.appendFileSync(file, data, [options])","fs.appendFile(file, data, options, cb)","fsPromises.appendFile(file, data, options)",Add text to the end of file
Delete file,fs.unlinkSync(path),"fs.unlink(path, callback)",fsPromises.unlink(path),Remove / delete file
Create directory,"fs.mkdirSync(path, [options])","fs.mkdir(path, options, callback)","fsPromises.mkdir(path, options)",Make a new folder
Read directory contents,"fs.readdirSync(path, [options])","fs.readdir(path, options, callback)","fsPromises.readdir(path, options)",List files/folders in a directory
Check if exists,fs.existsSync(path) (old) or use fs.accessSync,"fs.exists(path, cb) (deprecated)","fsPromises.access(path, mode)",Check file/dir accessibility


there will be a wrapper which wraps the entire typed code in node.js
Example:

function wrapper (exports, requests, module, --filename, --dirname) {
    const fs = require("fs");
    // console.log(fs);

    const content = fs.readFileSync("notes.txt", 'utf-8');
    console.log(content);
}

here, require function can be used only because require function is present within the wrapper. I fyou try to use require in browser console, you can't access it nd returns error.

Node.js gives require function, lind of module name i want to load. It checks if there are any 3rd party installation(json web token) along with the or present in the module. Then it checks for built-in module(fs). But both are not there, it throws an error.

require('./math.js')  -  one dot is single directory, two dots means behind 2 directories. So, if you use './', nodejs will get to know that it is a 'custom module'.

require also does something called as "internal Caching" which we will be explained in the upcoming topics.


-----------------

Video -20
---------

npm - node package manager(suggestd name but won't find the same name in google)

typings install that is if i type fs. there are no suggestions shown. Fir that, we have to install an external package, "@types/node" which is maintained by micrsoft.

To install it , we have to "make the project(index.js) as a package". To do that, on the root of the folder, we have to create a file "package.json" file which is configuration file for our project which contains name, version, scripts, dependancies(libraries or modules used), etc. So, we have to run the command "npm init". Later, fill in the command options after running it module name, etc.

As you can see, there is no "dependancies" in package.json. So we have to add that and what it does is it keeps track of third party dependancies. To do it, as I have mentioned above, run @types/node command.

As soon as you installed dependacies, a file called "node_modules" appeared automatically. This is a folder which contains the source code of the third party dependancies.

What it does is, when i type npm i package_name, it fetches the package from the internet. It then gets the source code from internet and keeps it inide the node_modules.

So, when you share the project, it looks into the dependancies, and install the required packages after we just type "npm i". So, that is the reason, it is not necessary to share the node_modules as well to the github or some other place. Also, it is very heavy in size and cannot be transferred easily.

"package-lock.json" stores info about which project depends on which one. FOr ex, if there are 3 projects, and if proj A is dependant on B, and B on C and then C on D. So, it stores all the info about these things. Basically it fetches the dependancies of the related or installed things.

-------------------------------------------

Video - 21
----------

We will explore fs module.

If you look in the syntax of nodejs documentation, they are using it as "require("node:fs")". This will be used more in the upcoming options. The reason is that the "node" keyword gives stand to "fs". This is required because if in future if anything new third-party fs arises, then this will clear the problem stating that this fs belongs to node that is built-in modules. But both does the same work and mean the same as of now.

There are two versions sync and aync.

Sync means that it is going to be an blocking operation. This will be thought in the upcoming videos.

You can write a file and read a file as well. 

fs.readFileSync - reads the content within the fs.

writeFileSync - writes or creates a new file with the text mentioned along with it in the syntax. It always "overwrites the content".

fs.appendFileSync - If you want to append or add the content to the already existing content within the file. 


You can also create DIrectory - fs.mkdirSync('games');
This creates a folder named "games".
If you want to create multiple folder inside it or at once, then:
fs.mkdirSync("games/xyz/a", { recursive : true });

To remove directory - fs.rmdirSync("games/xyz/a", { recursive: true });

You need to remove one by one as per the video. But for me everything got remove with a single command by using only 'games' that is, fs.rmdirSync("games", { recursive: true });.

we can create and  then delete a file using "fs.unlinkSync". Example:

// fs.writeFileSync("sample.txt", "I am creating a new file using writeFileSync", "utf-8");

// fs.unlinkSync("sample.txt");


Differece between "rmdirSync and unlinkSync" is that:
unlinkSync - Deletes a file or symbolic link (symlink)
rmdirSync - Deletes an empty directory (folder)

So, for third party modules we will use require("fs"); and for built-in modles we will use require("node:fs");

----------------------------------------------

Video - 22
-----------
Blocking vs Non-BlockingCode Execution in Node.js

I created a new script.js file and am doing the code there.

Sync Operations :
Blocking Operations.
Step by Step execution

console.log("Start of Script");

const contents = fs.readFileSync("copy.txt", "utf-8");

console.log("Contents", contents);

console.log("End of Script");

Output Order - 1, 2, 3.

Real World Example - Won't be used in websites as it delays the process.


Async Operations:
Non-Blocking.
Doesn't wait for big data and executes other steps in the meantime.


fs.readFile("copy.txt", "utf-8", function(error, data) {
    if (error) {
        console.log(error);
    }
    else {
        console.log("COntent got: ", data);
    }
})


console.log("End of Script");

Output - 1, 3, 2.

Callback Function is required in async operation because it needs to display something or let the user know is the task has been succesfull by completeing the task (data), or it didnot due to some error(error).
Data and Error are used as parameters i Async Functions.


Video-23
---------

Internal Architecture of Node.js: EVents Loop and Thread Loop


You will be having a "Node.js Server". Within that there will be "Event Queue" and "Event Loop".

EVent Loop will be contsantly listening to the Queue. 

For exmaple: 
I have created a website and users start hitting it. The request sent by the user or users who first sent the request before another user will be stored within the Event Queus. It will be stored in a certain order which supports "FIFO". Then Event Loop will be constantly watching the Queue.

Now the importatnt part starts.
The Event Loop checks or accepts the first user request which will be stored in an order, and checks whether if it is a Blocking operation or Non-Blocking Operation. So lets say if the task is blocking operation. Then event loop will execute the first code. Then it will take a lot of time if it needs to complete blocking operation, and the other users or requests will be on hold and has to wait.

Second Important Part.
Non-Blocking operation is something which is a CPU-intensive task(heavy task which requires a cpu). Thread Pools are offloaded to work on a cpu-intensive task, and the space or size can be altered.

Now, imagine if it is a Non-Blocking Operation, it transfers the data or request to something called as "Thread Pool". This Thread Pool is placed outside the "Node.js Server". Then Event Loop will distribute as much tasks to the threads inside the Thread Loop as much as possible. Imagine one non-blocing task to one thread within a thread loop. One thread will complete the task, and gives it back to the user.


Now, the other case is, if you want a synchronous option only like a gameboard game, where one user has to wait till the first user completes his round, then we need Synchronous Operations.

So, the conclusion is, it's not like sync operations are bad. It depends on the use case.

