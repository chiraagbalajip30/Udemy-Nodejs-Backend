Video-27 Buffer Thoery
------------------------

Data is stored in numbers according to our knowledge. But it also contains psaces like: 0101 010111 0001 0011. This is called as binary which has something of base 2.

From binary, thhis gets converted to a number like 1,54, or some number according to the binary number, and then it will get converted to an alphabet m or something, and then hjoined as a sequence of letters. moiurya. Then an emojie or something. 
This was jsut an example.

0048 - H
UTF-8 Encoding  -  0X48
UTF-16 Encoding  -  0X0048
UTF-32 Encoding  -  0X00000048


There will be a memory. There will be some representation of 8 bytes or some other bytes. You have to write the data in the allocated space and thenb read it.

So, Buffer is allow me to write some data of my choice and then read it.
For ex, you cannot read those files directly. You have to upload them to the memory, and then it does the job through the OS. 



What are Buffers in Node.js?

A Buffer is a temporary storage area for binary data.
Node.js does not support direct binary maniplation (like C/C++). So, Buffers handle raw data efficiently.
Uesd mostly when dealing with fle structures, network data and binary protocols.


CHATGPT EXPLANATION:

A Buffer is:

A fixed-size chunk of memory used to store raw binary data (bytes).

Think of it as:

an array of numbers (0‚Äì255)

where each number = 1 byte

allocated outside JavaScript‚Äôs normal memory



2Ô∏è‚É£ Why Buffers exist in Node.js

JavaScript was originally made for text and UI, not:

files

images

audio

network packets

Node.js runs on V8, which:

understands strings & objects

does NOT handle raw binary efficiently

But Node.js deals with:

files üìÅ

sockets üåê

streams üì°

üëâ So Node introduced Buffer to bridge this gap.



3Ô∏è‚É£ What does ‚Äúbinary data‚Äù mean?

Binary data = raw bytes

Examples:

image file (.png, .jpg)

audio file (.mp3)

video

network packets

encrypted data

This is NOT text ‚Äî it‚Äôs just bytes.


Buffer is NOT resizable
const buf = Buffer.alloc(3);
buf.write("Hello");

console.log(buf.toString());



6Ô∏è‚É£ Creating an empty Buffer (manual memory)
const buf = Buffer.alloc(5);
console.log(buf);


Output:

<Buffer 00 00 00 00 00>


5 bytes allocated

initially filled with 0




7Ô∏è‚É£ Writing into a Buffer
const buf = Buffer.alloc(5);
buf.write("Hi");

console.log(buf);
console.log(buf.toString());


Output:

<Buffer 48 69 00 00 00>
Hi




8Ô∏è‚É£ Reading binary data (File example)
üìÅ Reading a file
const fs = require("fs");

const data = fs.readFileSync("image.png");
console.log(data);


Output:

<Buffer 89 50 4e 47 ... >


That is raw binary file data.

If you tried to treat this as a string ‚Üí üí• corruption.




4Ô∏è‚É£ Creating a Buffer
Example 1Ô∏è‚É£ ‚Äî From a string
const buf = Buffer.from("Hello");
console.log(buf);


Output:

<Buffer 48 65 6c 6c 6f>


Those numbers are hexadecimal bytes.




Example 2Ô∏è‚É£ ‚Äî Convert Buffer back to string
console.log(buf.toString());


Output:

Hello




5Ô∏è‚É£ What‚Äôs actually inside the Buffer?
const buf = Buffer.from("A");


Character A:

ASCII value ‚Üí 65

Hex ‚Üí 41

So buffer stores:

<Buffer 41>


üí° Buffers store bytes, not characters.




Interview-level explanation (memorize this)

A Buffer in Node.js is a fixed-size memory allocation used to handle raw binary data. Since JavaScript cannot efficiently process binary data, Node.js provides Buffers to work with files, streams, and network operations at the byte level.


Course Content

JS are UTF-16 encoded, making direct binary data handling ineffcient.
Buffers store binary data outside V8's heap.
Useful wehn wroking with: File System (fs module), Networking (TCP, UDP, WebSocket), Streams.



------------------------------------ 
Video-28 Buffer Coding Explanation
---------------------------------



Nodejs docs:
When converting between Buffers and strings, a character encoding may be specified. If no character encoding is specified, UTF-8 will be used as the default.

const { Buffer } = require('node:buffer');

const buf = Buffer.from('hello world', 'utf8');

console.log(buf.toString('hex'));
// Prints: 68656c6c6f20776f726c64
console.log(buf.toString('base64'));
// Prints: aGVsbG8gd29ybGQ=

console.log(Buffer.from('fhqwhgads', 'utf8'));
// Prints: <Buffer 66 68 71 77 68 67 61 64 73>
console.log(Buffer.from('fhqwhgads', 'utf16le'));
// Prints: <Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00>



allocUnsafe won't clean the memory like from or toString.
const buffTwo = Buffer.allocUnsafe(10);
console.log(buffTwo);
// <Buffer 00 00 00 00 00 00 00 00 00 00>
// here it is clean, but there might be some data which are blank. (Garbage Value)




Buffer.allocUnsafe() allocates memory without initializing it, which makes it faster but potentially dangerous. It should only be used when the buffer will be fully overwritten before being read, otherwise it may expose sensitive memory data.





so you are saying that if every byte in the memory allocated suppose 5, is equal to data(hello-5 letters) only then we must use this?

what are we even readidng or sending it to whom?

Answer:

1Ô∏è‚É£ First question ‚Äî ‚ÄúSo should we use it only if bytes == data size?‚Äù

Short answer:
üëâ Yes ‚Äî OR when you are 100% sure every byte will be overwritten before use.

Example you gave (correct understanding ‚úÖ)
const buf = Buffer.allocUnsafe(5);
buf.write("Hello"); // 5 bytes


Buffer size = 5 bytes

Data size = 5 bytes

Every byte overwritten

‚úÖ Safe




2Ô∏è‚É£ Second question ‚Äî ‚ÄúWhat are we even reading or sending, and to whom?‚Äù

This is the MOST IMPORTANT PART üëá
Buffers are almost never used alone ‚Äî they are used to move data.

Where buffers are READ from
1Ô∏è‚É£ Files
fs.readFile("file.txt", (err, data) => {
  // data is a Buffer
});


You‚Äôre reading:

file contents

binary data

2Ô∏è‚É£ Network (TCP / HTTP / WebSocket)
socket.on("data", (chunk) => {
  // chunk is a Buffer
});


You‚Äôre reading:

data sent by a client

packets from the internet

Where buffers are SENT to
1Ô∏è‚É£ HTTP responses
res.end(buffer);


You are sending data:

to a browser

to an API client

to another server

üö® If buffer contains garbage ‚Üí client receives it

2Ô∏è‚É£ File writes
fs.writeFile("out.bin", buffer);


You are sending:

memory contents

into a file

Garbage bytes ‚Üí corrupted file

3Ô∏è‚É£ Network sockets
socket.write(buffer);


You are sending:

raw memory

over the network




One perfect mental model üß†

Buffers are like unwashed plates
allocUnsafe() gives you a plate that might already have food
If you don‚Äôt wash it completely before serving ‚Üí someone eats leftovers

Final crystal-clear rule (memorize)

If a buffer ever leaves your process,
it must be fully written before reading or sending.

You‚Äôve understood this topic deeply now ‚Äî this is systems-level thinking.