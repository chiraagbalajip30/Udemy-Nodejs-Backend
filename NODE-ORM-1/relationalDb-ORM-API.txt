Video - 47
-----------
Explanation of Relational and Non-Relational DBs

To begin with, let's understand what the applications in real-world look like.
So, client(through frontend) interacts with the server(which is currently being built in Node.js).
The purpose of the server is to accept or take the request, and do some processing on the response, and hen return back the response. 
There is a lot of work to do while processing the data. While processing the data, you might have to get some data from the database, you might want to add some data into the database, or update something, or do something in the cache store, trigger some email, etc, and then send back the response. 
So, the most or commonly used thing here is the database. 
Database -  It is a system or a place where you can store all the application data. Ex, users signes up, passwords, preferences, data, etc. So, interacting and modeeling the database is an important thing, and is very important for the backend engineer.
There are 2 types of database: NOSQL and SQL Database.

SQL:
-------
Relational Database
Structured Data
Ex: Users object has id, name, email, pasword, profile image, etc. If we are building something like Facebook. You have multiple users. Now we will assign user A, user B, user C. Now, A has sent request to B, and we have to build a relationship between A and B in the database. So, we will create a Friends table in the database. So to identify friends, user_first and user_second, then user_first and user_third.
user_first:A             user_first:A
user_second:B            user_third:C
So, if we want to check how many friends a or b or c has, we can identify that A has 2 friends, B has 1 and C has 1. Also, B and C has one mutual friend A.

So, two make relatioships beween them, we use relational dbs, and it is very structured. 
Here, in this example, we are talking about one-many relationship. 

Database Examples - MySQL, Postgres, etc.


NOSQL:
-------
Non-Relational  Database
Non-Structured data

Here,there are no relations. If i try to access gender columns without initalizing or adding it, it will throw an error that first we have to create a column, and then use or initialize it. Wehereas, in NOSQL or non-relational db, we can do that. Here, we have users table, and we can store any key and any value inside it. So, for storing friends, we can create an array, and then store friends as a, b,c. There are no relationships or boundaries here. Flexibility is more here. 

Database Examples - MongoDB.

Here, in this course, we will learn Postgres first and later move onto MongoDB because, learning structured db is very much required, and it gives proper idea about the database. Once we learn Relational DB, then Non-Relational Db would be a piece of cake to learn.



Video - 48
-----------
What is an ORM and why it is used in Application Development


Drizzle, Knex and Prizma is an ORM, and there are many more.

ORM - Object Relation mapper/mapping.

Google Def:
ORM - Is a piece of software designed to translate between the data representations used by databases and those used in object-oriented programming. 

Ex - I can speak Kannada language. Tere is an person whose is deaf and dumb. Now, we need to communicate to them. So now we will build a software, which coverts Knnada language to braile language. Now, the communication is very easy with the help of ORM.


Real-world:
Now, we have a javascript piece of code, and we have an postgres db. Now if we want to create a user table, we will write the user within the dict and assign them. Now, we want to store this into DB. But we cannot send them directly into the db as it couldn't understand. Now we will install ORM because it has connection to the db. Now this ORM is Javascript ->(to) Postgres. Now we can take this objet and give it to the ORM. Now this ORM will convert this object into SQL query, and then stores this into the postgres table. Now, let's say we want to read the user, then ORM will fire a query to read it like: SELECT * FROM USERS:, and then it returns some tabular data. Now, this syntax is not understandable by hJS. Now this ORM converts into JS Syntax, and gives it to the JS. 

SO, we can use Drizzle for JS -> MySQL and JS -> POSTGRES. 
SImilarly, JS -> MongoDB, we use Mongoose.
Then from Python -> Postgres, we use SQLAlchemy. 
Python -> MongoDb, we use PI Mongo.
There are many ORM's available for related language use.
Prisma = JS -> Any Database i.e, JS -> MongoDB, PostgresSQl, MySQL,etc.



CHATGPT Version:
-----------------

‚úÖ Proper Explanation (Refined Version)

In a real-world backend application, we usually work with JavaScript code and a database like PostgreSQL.

When we create data in our application, we typically represent it as a JavaScript object.

For example:

const user = {
  email: "a@b.com",
  password: "123456"
};


However, databases do not understand JavaScript objects directly. They only understand SQL queries.

To bridge this gap, we use an ORM (Object Relational Mapping) tool such as Prisma or Sequelize.

How ORM works when storing data

1Ô∏è‚É£ We pass the JavaScript object to the ORM.

2Ô∏è‚É£ The ORM converts the object into an SQL query like:

INSERT INTO users (email, password)
VALUES ('a@b.com', '123456');


3Ô∏è‚É£ The database executes this query and stores the data in a table.

How ORM works when reading data

1Ô∏è‚É£ We request data using ORM methods like:

prisma.user.findMany();


2Ô∏è‚É£ The ORM generates an SQL query such as:

SELECT * FROM users;


3Ô∏è‚É£ The database returns rows of data (tabular format).

4Ô∏è‚É£ The ORM converts these rows into JavaScript objects, which our application can easily use.

Example result:

[
  { id: 1, email: "a@b.com", password: "123456" }
]

Why we use ORM

ORM makes development easier because:

We don‚Äôt have to write SQL for basic operations

Code becomes cleaner and easier to maintain

It reduces bugs

It improves developer productivity

Do we always avoid SQL?

No. In real-world applications:

Most common operations use ORM methods

Complex or performance-critical queries may still use raw SQL

Real application flow
JavaScript Object ‚Üí ORM ‚Üí SQL Query ‚Üí Database
Database Result ‚Üí ORM ‚Üí JavaScript Object

Industry practice

This is the standard approach used in most modern backend applications. Developers typically use an ORM along with SQL knowledge for building scalable systems.




video - 49
-----------
Setting Up PostgreSQL with Docker for Local Development


PostgresSQl is one of the most powerful SQL, and almost all the companies use this. 

There are 3 methods to download the PostgresSql:
1. Full Download - Go to the official PostgresSql website, and download the suitable version for windows. The disadvantage of this is that you can only use one database as, you have installed it in the system, which is not right and won't be suitable in the future.
You can download this from -  https://www.postgresql.org/download/windows/ link.

2. We can download postgressql, and setup and store it in cloud. Then we can connect our local machine to the cloud. So, there are two disadvantages from this: 1. We will incur a cost.  2. There will be a latency in the usage as the database is hosted i the cloud, and the data fetching will become late.
You can use superbase -  https://supabase.com/  for this. How it works is first we need to sign in, then create a project. It will give us the username, password and the URL using which we can connect our local machine to the database.

3. Hybrid Approach - We can use something called as Docker. Inside the Docker, we can spin up the postgressql instance kind of virtual environment. We are not installing it on our system, we are just running it on the virtual environment from our sytem. Once our work is done, we can delete the created instance, and it won't harm our local system. 
We can download it by :  https://www.docker.com/ , and then click for windows.


After that, install and run few commands to make it properly work, and then check the version in te terminal.

Now, we have to set up the postgres inside the docker.



Now I created a folder called NODE-ORM, and created a docker-compose.yml file inside it, and also pushed the notes of relationaldb ffrom other foler to this folder.

After creating docker-compose.yml, you can see the docker logo on the left hand side of the docker-compose.yml file. 

What is a docker-compose.yml file?

A docker-compose.yml file is a configuration file used by Docker Compose to define and run multiple containers together.

Think of it like a blueprint that tells Docker:

What services to run (database, backend, frontend)
Which images to use
Ports
Environment variables
Volumes
Networking


We can assign the required dtabase that is, postgres, and then mention the required version to be instaled like 17.4. Later, the port that runs postgres db is 5432. Then we must declare environment, which contains te credentials for this particular postgres.

Then we have to type "docker compose up" for this to run continously.

Immportant:   - 5432:5432  there must be a space after "-", and then the port must be written.


So once I start running this and press Ctrl+C, it stops working(terminal ends and the postgresdb in docker stops running, and can be observed as the dot is unfilled).
What can be done is, instead of running "docker compose up" command, we can run "docker compose up -d", and you can observe pressing ctrl+C wouldn't end the process(db) or stop the container from running. Then to remove db, we can type "docker compose down".

Now, docker setup is completed.

So, the benifit of docker is that we can define mongodb or other db's and can run al of them by mentioning in this file.

To view the raw file, we need to run the command:
"cat docker-compose.yml".


-----------------------------------------------


Video - 50
-----------
Installing and Configuring Drizzle ORM with PostgresSQl

https://orm.drizzle.team/docs/get-started/postgresql-new




Why are we using Drizzle instead of Prisma, or other ORMs?
Choosing ORM is a big decision.
Prisma is suitable for all languages, but the disadvantage is that it is not that efficient for making queries. 
If we use Prisma for suppose extracting or getting details of a user and his friends, we must write two queries. Whereas, in Drizzle, we can do those two operations in a single query.
Prisma is good because we can switch between different db with one click. But the disadvantage is that it has performance issues. It has difficulty in Foreign Relationship Join. Prism team is fixing it now.

Drizzle is built on top of Prisma. It internally uses Prisma, but has more efficient querying system with Postgres and MySQL. They don't support NOSQL. 


Basic File Structure
---------------------

üì¶ <project root>
 ‚îú üìÇ drizzle
 ‚îú üìÇ src
 ‚îÇ   ‚îú üìÇ db
 ‚îÇ   ‚îÇ  ‚îî üìú schema.ts
 ‚îÇ   ‚îî üìú index.ts
 ‚îú üìú .env
 ‚îú üìú drizzle.config.ts
 ‚îú üìú package.json
 ‚îî üìú tsconfig.json



Step 1 - Install node-postgres package
--------
Create drizzle named folder, create a drizzle.config.js file in the root directory and then Install - Package.json(npm init), npm i drizzle-orm pg(drizzle-orm is used for our interaction, and pg is postgres package installation).



Step 2 - Setup connection variables

Create a .env file in the root of your project and add your database connection variable:
-----------------------------------------
Now we want to setup dotenv variables, which will be explained later.



Step 3 - Connect Drizzle ORM to the database

Create a index.js file in the src directory and initialize the connection:
--------
Now, we have to create a db folder, and create a index.js file within it. 
Within index.js, we must import drizzle-orm/node-postgres. These can be found in the docs. This is for connection of Drizzle ORM to the database[const { drizzle } = require("drizzle-orm/node-postgres");]. 

Now we have to attach db to the drizzle, and this is the format:  // postgress://<username>:<password>@<host>:<port>/<db_name>
We have to put our details instead of these to make a url. 


const { drizzle } = require("drizzle-orm/node-postgres");

// const db = drizzle(process.env.DATABASE_URL!); this is the syntax in docs
// postgress://<username>:<password>@<host>:<port>/<db_name> //  pattern to be followed

const db = drizzle("postgres://postgres:admin@localhost:5432/myDb");

module.exports = db;



Step 4 - Create a table

Create a schema.js file in the src/db directory and declare your table:
-------
Now, we have to create a table. That is, we have to define a schema as we are working on structured schema or db. 

Now let us create a schema.js file inside drizzle folder. 


Now we will import some data types, and then create a table. 

const {pgTable, integer, varchar} = require( "drizzle-orm/pg-core");

const usersTable = pgTable("users", {
    id: integer().primaryKey(),
    name: varchar({length: 25}).notNull(),
    email: varchar({length:255}).notNull().unique(),
});

// exporting an object so written within {}
module.exports = {
    usersTable
}


pgTable is a function provided by Drizzle ORM that is used to define a table schema for PostgreSQL.


‚úÖ pgTable ‚Üí function to define PostgreSQL table schema
‚úÖ Converts JS schema ‚Üí SQL structure
‚úÖ {} in export ‚Üí exporting as an object with named properties
‚úÖ Allows exporting multiple things



Step 5 - Setup Drizzle config file

Drizzle config - a configuration file that is used by Drizzle Kit and contains all the information about your database connection, migration folder and schema files.

Create a drizzle.config.ts file in the root of your project and add the following content:
----------------------------

Install drizzle-kit first by typing "npm in drizzle-kit" in the terminal.

You can see these in package.json:
"drizzle-kit": "^0.31.9",
"drizzle-orm": "^0.45.1",

D/b these two is: 
drizzle-orm  -  Send and Recieve data from DB
drizzle-kit  -  Send your schema to the db or you have to hav UI for your db.


dialect: "postgresql",  -  db i am going to use

out: "./drizzle",  -  where to keep all my related schemas and everything like that

schema: "./drizzle/schema.js",  -  Where are you going to store the data.


db/index.js - This file is used when you need to send the data to the database, or receive it.
We will ignore this for now.


Step 6 - Applying changes to the database
You can directly apply changes to your database using the drizzle-kit push command. This is a convenient method for quickly testing new schema designs or modifications in a local development environment, allowing for rapid iterations without the need to manage migration files:

npx drizzle-kit push
------------------------------------------------

Now the docker doesn't know that there is a schema of users. 
So, now we are going to ask drizzle.config.js file "Can you please read my Schema File?".

This can be done by the step-6 command. 


After running this, you must type "npx drizzle-kit studio". This gives you the link for Ui as well. 
It gave me this link:  https://local.drizzle.studio


Now let uss say we want to do something or create a user where ORM will come. 

Create an index.js File in the root directory, and connect the schema dna db by exporting the modules within this files, and then run the file: "node index.js".

Code for this explanation:

const db = require("./db/index");
const { usersTable } = require("./drizzle/schema");

async function getAllUsers() {
  const users = await db.select().from(usersTable);
  console.log(`Users in DB`, users);
  return users;
}

async function createUser({ id, name, email }) {
  await db.insert(usersTable).values({ id, name, email });
}

createUser({ id: 1, name: "MCB", email: "mcb@123.com" });
createUser({ id: 2, name: "P", email: "p@123.com" });




Then when i comment createUsers, and type "getAllUsers", then i will get output in log as an object:

Users in DB [
  { id: 1, name: 'MCB', email: 'mcb@123.com' },  
  { id: 2, name: 'P', email: 'p@123.com' }       
]

Output is an Object because Drizzle is doing that.

So, this is the overall job of the rizzle ORM. It converts the JS into SQL query, and returns us back an object. 

This is the full setup of an Drizzle ORM.

But in the upcoming videos or upcoming videos what we are going to do is, set up an Express REST application, and all the creations and updations has to go through the Neck Express API endpoints. That is, we are going to create an endpoint for getting an user, creating an user, etc.  


Now we have left one thing. It is not a good idea to harcode url in our application. It becomes easy to hack when published. So we maintain dotenv file. Here we place our sensitive data.  

.env is never given to someon or given to anyone. But it is read through installing dotenv package. So install it now by running:  "npm i dotenv".

require("dotenv/config");
 //tries to read the dotenv file before everything else. It must be placed at the beginning of the file after all the exports are done. 

The above line readsit and makes it available everywhere within the code.

Now we will remove the link in schema and replace it with:
const db = drizzle(process.env.DATABASE_URL);


require("dotenv/config");
const db = require("./db/index");
const { usersTable } = require("./drizzle/schema");

// dotenv.config(); //tries to read the dotenv file before everything else

async function getAllUsers() {
  const users = await db.select().from(usersTable);
  console.log(`Users in DB`, users);
  return users;
}

async function createUser({ id, name, email }) {
  await db.insert(usersTable).values({ id, name, email });
}

// createUser({ id: 1, name: "MCB", email: "mcb@123.com" });
// createUser({ id: 2, name: "P", email: "p@123.com" });

getAllUsers(); // Output is an Object because Drizzle is doing that.



require("dotenv/config");
const { defineConfig } = require("drizzle-kit");


const config = defineConfig({
  out: "./drizzle",
  schema: "./drizzle/schema.js",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});

module.exports = config;



















