Video - 36
-----------
Intro to Express Framework and its Core Features



The code that we have written till now is very messy. This will be more complex with more number of developers, db integration, etc only by using switch cses and makes it more messy.
So you need some framework fro neat and readable code.

So from now, we will be using Express.js. This internally uses only http to create servers, and provides a clean structure for writing code.

------------------------------------------------

Video - 37
--------------------
Creating your first Express App and File Structure Setup


We created a folder 01_express. Then installed node modules and dependancies by typing "npm init -y" and later "npm i types/node". 
We have to add an extra step here or install something called as "npm i express", which will basicaly download the express module or package for you.
Then for extensions when clicked".", we need to install "@types/express".


By default, express sends "200" status code. SO, if you want to change it, you can use status(code). Example:
app.post("/tweets", (req, res) => {
    res.status(201).end('TWeet Created Successfully');
})

----------------------------------------

Video - 38
-------------
Understanding Semantic Versioning in Node.js Projects



{
  "name": "01_express",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node --watch index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@types/express": "^5.0.6",
    "@types/node": "^25.2.2",
    "express": "^5.2.1"
  }
}

Here, there is something called as Semantic Versioning. "^5.2.1" whjat the numbers stand for and everything.


Semantic Versioning has 3 Numbers also known as Bits.
First Bit always tells us that it is the Major Version. 
Second Bit is Minor Version.
Third Bit is known as Patch Version.

Patch: Incremented for backward-compatible bug fixes. These updates addres issues without addingd new functionality or breaking anything. For instance, 1.2.3 to 1.2.4 signals a bug fix that doesn't affect compatibility.

Minor: Aded a new feature but old features will also work.

Major: A lot of code changes must be done. Incremented when there are incompatible API changes. These changes may break existing functionality or require modifications in dependent code. For example, 1.0.0 to 2.0.0 indicates a significant change that may require users to update their code.

"~5.2.1" - This symbol says that if in future, it will install all the patch updates automatically. Ex:  from 4.21.1 -> 4.21.x

"^5.2.1" - Never ever update the Major Version. Ex: from 4.21.1 -> less than 5.0.0


If any updates, when we do npm i, it goes to npm js.com which is a official website, and from there everything related to js will be installed.


--------------------------------


Video - 39
-------------
REST API Design Principles for Modern Backend Development



Restfull API - Representational State Transfer.
This is an architectural style, and it is not related to NODE.JS. It is just a style for designing API's for backend development.

There are some principles:
1. All the communication happens on the HTTP.
2. Statelessness - There must be no state maintained on the server. That means, the memory of the sewrver cannot be used to store any user-related info or ay info. They must be stored in DB. The reason is, there might be scale-up or scale-dow in the memory(servers). At that time, if any data is stored in the server(memory), the dta may be lost forever. 
3. It must follow Client-Server architecture. It means client and server must be a separate application. If somehting happens in frontend, backend shouldn't be responsible and vice-versa. For explantion, no html or css must be sent from the backend. The data must be sent through json to the frontend. 
4. There should be Uniform Interface. We should use get, post, etc methods in a predictable way. Example: if we type get/tweets, it must be to fetch not to post. It is not logical if we write get and then post.
5. Respponses sent from the backend must be Cachable.

We will be usingf this principles in the future and must be used for high-performance applications.


---------------------------------------------------

Video - 40
-----------
Book Store API - Setting up Routes and Controllers(Part-1)


I have attached the explanation or tasks of this and next video in the file "bookStoreTask.txt". Look into it for tasks and then start solving them parallely.


Firstly, I created an folder for this task known as bookExpressStore andinstalled packages by typing "npm init -y". TLater, to install dependancies, instead of typing "@types/node", I typed "@types/node -D or @types/node --save-dev". What this does is it installs the dependancies within the devDependancies. The advantage of doing this is that, dependancies are required only during development time. After development, during the production time, we don't need this. It wouldn't be a problem if dones so. But it does that and acts as an advantage. So, we used this command.  


// In Memory Database
// Here i am violating the statelesness rules as i donot have a database.
I am storing the data within the array in the index.js itself. Therefore, it violtes the rules.


app.get("/", (req, res) => {
    res.json(books);
})
Here, if we use res.end, it returns only plain text. But in real case scenario, we need to send arrays or something else, which must be capable to return key-value pairs or these kind of data. 
Internally, express will do is convert this array into a json and sit all the appropraite headers, and send these books as a JSON to the frontend.


// Routes
app.get("/", (req, res) => {
    // res.setHeader('x-bd', 'mcb'); // manually fixing the header
    res.json(books);
})

You can also fix the header manually whichever you want. This is an extra header ig. SO, when you view in the headers colum in thunderclient or postman once you send the request to a certain url, you can see them there.
Alos, it's a good practice if you start the custom header with "x".


Header                Value
x-powered-by          Express
This is what you will see in the headers. So it's not an extra header, it is the header.


app.get("/books/:id", (req, res) => {
    const id = req.params.id;
    const book = books.find((e) => e.id === id);

    if (!book) {
        return res.status(404).json({ error: "Book not found" });
    } else {
        return res.json(book);
    }
})
Here, we are trying to send a req to slect one single books based on id. SO, we annotate it by using "/:id". Later, we use req.params to grab the id from the parametrs of the request. by allocating it to the const variable such as const id. (There can be multiple params as well like /:id/:r/:a, etc.). Later, we have to find that variable(id), and match that to the books.id. 

We wont get the output because we have a problem here. The id must be converted to or must be a string. SO we have two options:
1.  const book = books.find((e) => e.id === id);  Remove === and make it ==.
2. This is the best way. We must add a parseInt const id = req.params.id; here. Now you will get the id of the respective book entered. BUt we can make it more clean or professional by adding a loop and by letting users know that, id must be only in numer format, not others like alphabets, etc. So to do that,  add a loop condition to check if the enterd id is not a number using:
 if(isNaN(id)){
    pass the 400 code, and an error message
  }


  -------------------------------------


  Video - 41
  -----------
Book Store API - Finalizing CRUD Features and Testing (Part-2)






