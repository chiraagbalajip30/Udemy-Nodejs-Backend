Video - 36
-----------
Intro to Express Framework and its Core Features



The code that we have written till now is very messy. This will be more complex with more number of developers, db integration, etc only by using switch cses and makes it more messy.
So you need some framework fro neat and readable code.

So from now, we will be using Express.js. This internally uses only http to create servers, and provides a clean structure for writing code.

------------------------------------------------

Video - 37
--------------------
Creating your first Express App and File Structure Setup


We created a folder 01_express. Then installed node modules and dependancies by typing "npm init -y" and later "npm i types/node". 
We have to add an extra step here or install something called as "npm i express", which will basicaly download the express module or package for you.
Then for extensions when clicked".", we need to install "@types/express".


By default, express sends "200" status code. SO, if you want to change it, you can use status(code). Example:
app.post("/tweets", (req, res) => {
    res.status(201).end('TWeet Created Successfully');
})

----------------------------------------

Video - 38
-------------
Understanding Semantic Versioning in Node.js Projects



{
  "name": "01_express",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node --watch index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@types/express": "^5.0.6",
    "@types/node": "^25.2.2",
    "express": "^5.2.1"
  }
}

Here, there is something called as Semantic Versioning. "^5.2.1" whjat the numbers stand for and everything.


Semantic Versioning has 3 Numbers also known as Bits.
First Bit always tells us that it is the Major Version. 
Second Bit is Minor Version.
Third Bit is known as Patch Version.

Patch: Incremented for backward-compatible bug fixes. These updates addres issues without addingd new functionality or breaking anything. For instance, 1.2.3 to 1.2.4 signals a bug fix that doesn't affect compatibility.

Minor: Aded a new feature but old features will also work.

Major: A lot of code changes must be done. Incremented when there are incompatible API changes. These changes may break existing functionality or require modifications in dependent code. For example, 1.0.0 to 2.0.0 indicates a significant change that may require users to update their code.

"~5.2.1" - This symbol says that if in future, it will install all the patch updates automatically. Ex:  from 4.21.1 -> 4.21.x

"^5.2.1" - Never ever update the Major Version. Ex: from 4.21.1 -> less than 5.0.0


If any updates, when we do npm i, it goes to npm js.com which is a official website, and from there everything related to js will be installed.


--------------------------------


Video - 39
-------------
REST API Design Principles for Modern Backend Development



Restfull API - Representational State Transfer.
This is an architectural style, and it is not related to NODE.JS. It is just a style for designing API's for backend development.

There are some principles:
1. All the communication happens on the HTTP.
2. Statelessness - There must be no state maintained on the server. That means, the memory of the sewrver cannot be used to store any user-related info or ay info. They must be stored in DB. The reason is, there might be scale-up or scale-dow in the memory(servers). At that time, if any data is stored in the server(memory), the dta may be lost forever. 
3. It must follow Client-Server architecture. It means client and server must be a separate application. If somehting happens in frontend, backend shouldn't be responsible and vice-versa. For explantion, no html or css must be sent from the backend. The data must be sent through json to the frontend. 
4. There should be Uniform Interface. We should use get, post, etc methods in a predictable way. Example: if we type get/tweets, it must be to fetch not to post. It is not logical if we write get and then post.
5. Respponses sent from the backend must be Cachable.

We will be usingf this principles in the future and must be used for high-performance applications.


---------------------------------------------------

Video - 40
-----------
Book Store API - Setting up Routes and Controllers(Part-1)


I have attached the explanation or tasks of this and next video in the file "bookStoreTask.txt". Look into it for tasks and then start solving them parallely.


Firstly, I created an folder for this task known as bookExpressStore andinstalled packages by typing "npm init -y". TLater, to install dependancies, instead of typing "@types/node", I typed "@types/node -D or @types/node --save-dev". What this does is it installs the dependancies within the devDependancies. The advantage of doing this is that, dependancies are required only during development time. After development, during the production time, we don't need this. It wouldn't be a problem if dones so. But it does that and acts as an advantage. So, we used this command.  


// In Memory Database
// Here i am violating the statelesness rules as i donot have a database.
I am storing the data within the array in the index.js itself. Therefore, it violtes the rules.


app.get("/", (req, res) => {
    res.json(books);
})
Here, if we use res.end, it returns only plain text. But in real case scenario, we need to send arrays or something else, which must be capable to return key-value pairs or these kind of data. 
Internally, express will do is convert this array into a json and sit all the appropraite headers, and send these books as a JSON to the frontend.


// Routes
app.get("/", (req, res) => {
    // res.setHeader('x-bd', 'mcb'); // manually fixing the header
    res.json(books);
})

You can also fix the header manually whichever you want. This is an extra header ig. SO, when you view in the headers colum in thunderclient or postman once you send the request to a certain url, you can see them there.
Alos, it's a good practice if you start the custom header with "x".


Header                Value
x-powered-by          Express
This is what you will see in the headers. So it's not an extra header, it is the header.


app.get("/books/:id", (req, res) => {
    const id = req.params.id;
    const book = books.find((e) => e.id === id);

    if (!book) {
        return res.status(404).json({ error: "Book not found" });
    } else {
        return res.json(book);
    }
})
Here, we are trying to send a req to slect one single books based on id. SO, we annotate it by using "/:id". Later, we use req.params to grab the id from the parametrs of the request. by allocating it to the const variable such as const id. (There can be multiple params as well like /:id/:r/:a, etc.). Later, we have to find that variable(id), and match that to the books.id. 

We wont get the output because we have a problem here. The id must be converted to or must be a string. SO we have two options:
1.  const book = books.find((e) => e.id === id);  Remove === and make it ==.
2. This is the best way. We must add a parseInt const id = req.params.id; here. Now you will get the id of the respective book entered. BUt we can make it more clean or professional by adding a loop and by letting users know that, id must be only in numer format, not others like alphabets, etc. So to do that,  add a loop condition to check if the enterd id is not a number using:
 if(isNaN(id)){
    pass the 400 code, and an error message
  }


  -------------------------------------


  Video - 41
  -----------
Book Store API - Finalizing CRUD Features and Testing (Part-2)



When you make a post req, you have to send a body, and json must be used for that.
The body has to be processed based on the content-type that is being sent by the frontend like tetx, xml, etc. For that, express has a concept known as "Middleware". 

// Middlewares(Plugins)
app.use(express.json());

This is a plugin, where we attach it use app anduse express.json. What it does is it converts the body type of frontend message or request to the desired type, and gives it to the backend.

Actual Explanation:
It does something where it uses some headers :Content_type":"application/json", and converts the body into the json, and give us the access as the body so that if there is a POST Route it helps us to get what inside the body using req.body.


So, we need to check if title or author is been sent, and is not an empty string. If not, we need to generate id for the new book by doing books.length that is, it gives the number of books present plus one.
Later, we need to create a book by passing author and title, and id will be generated by books.length.
const book = { id, title, author };
books.push(book);
Later, we will push the created book to books database.
















CHATGPT
-------

| Scenario         | Format              |
| ---------------- | ------------------- |
| Login / Signup   | JSON                |
| Forms (no files) | JSON                |
| Image upload     | multipart/form-data |
| API response     | JSON                |
| File download    | Binary              |
| WebSockets       | JSON / Binary       |
| Streaming        | Binary              |


9Ô∏è‚É£ Interview-ready answer (use this)

Frontend and backend usually communicate using JSON for API requests and responses. However, for files, streams, or real-time data, binary formats are used, and on the backend these are handled using Buffers.

üîë One mental model üß†

JSON is for data.
Buffers are for transport.


Frontend sends:

fetch("/api/login", {
  method: "POST",
  headers: {
    "Content-Type": "application/json"
  },
  body: JSON.stringify({
    email: "a@b.com",
    password: "123456"
  })
});


Backend receives:

req.body
// { email: 'a@b.com', password: '123456' }


Backend sends:

res.json({
  success: true,
  token: "abc123"
});


Frontend receives:

const data = await res.json();



JSO.stringify() - It converts the JS object into a JSON-formatted string.


You‚Äôve now connected:
JS object ‚Üí string ‚Üí buffer ‚Üí network ‚Üí buffer ‚Üí object



Yes ‚Äî exactly üëç
JSON.stringify(...) converts the data to a string before it is sent.

Let‚Äôs walk through what actually happens, step by step.

1Ô∏è‚É£ What fetch can send over HTTP

HTTP cannot send JavaScript objects.

It can only send:

text (strings)

bytes (binary data)

So this ‚ùå is impossible:

body: { email: "a@b.com" }

2Ô∏è‚É£ What JSON.stringify() does
JSON.stringify({
  email: "a@b.com",
  password: "123456"
})


It converts the JS object into a JSON-formatted string:

"{\"email\":\"a@b.com\",\"password\":\"123456\"}"


This is:

plain text

UTF-8 encoded

ready for transport over HTTP

3Ô∏è‚É£ What is actually sent over the network

What travels over the wire is:

email":"a@b.com","password":"123456"


as bytes (internally).

So the flow is:

JS Object
   ‚Üì JSON.stringify
String
   ‚Üì UTF-8 encoding
Bytes (Buffer)
   ‚Üì Network
Backend

4Ô∏è‚É£ Why we must set Content-Type: application/json
headers: {
  "Content-Type": "application/json"
}


This tells the backend:

‚ÄúThe incoming bytes represent JSON text.‚Äù

Without it:

backend won‚Äôt parse automatically

req.body may be undefined

5Ô∏è‚É£ What happens on the backend (Node.js / Express)
Incoming data:

arrives as Buffer

contains JSON text

Express does:

JSON.parse(buffer.toString())


So you finally get:

req.body = {
  email: "a@b.com",
  password: "123456"
}

6Ô∏è‚É£ Important contrast: FormData
FormData does NOT stringify
body: formData


Browser:

builds a multipart body

sends binary + text

no JSON involved

Backend receives:

files ‚Üí Buffers

fields ‚Üí strings

7Ô∏è‚É£ One-sentence rule (remember this)

JSON.stringify() converts a JavaScript object into a string so it can be sent over HTTP.





