Video - 51
------------
Migrating Book Store to Drizzle ORM - Part 1: Schema Setup


Firstly, we need to create a docker-compose.yml file. 
Talking about ports in .yml file, we can set it as 5431 but the defaut must be -542:5432. So., it's better to delete the old containers running on that port in docker(previous video is running on this port so delete it).

Chatgpt Content:
-----------------
image in docker-compose.yml file:

instead of installing:
PostgreSQL,
Dependencies,
OS libraries,
Configuration,
Docker just pulls the image which already contains everything.



Why do we need Drizzle-kit?

Why do we need drizzle-kit?

Remember â€” in Drizzle you define tables in code like:

pgTable("users", {...})

But writing schema in code alone does NOT create tables in the database.

ðŸ‘‰ You still need to update the actual database.

Thatâ€™s where drizzle-kit comes in.

What drizzle-kit does in simple words

ðŸ‘‰ It converts your schema code â†’ SQL migration files
ðŸ‘‰ Then applies those migrations to your database

So, users creates a schema, then it calls dizzle-generate, and then drizzle-migration, and then npx drizzle-kit push.


Course Content:
Then, we installed npm i dotenv, npm i drizzle-orm pg, and npm i drizzle-kit.
Now , all the packages are installed. 


Setup everything that is files. Schema.js is created inside models folder, and is renamed as book.model.js.

// These kind of Foreign-Table relationships are not possible in MongoDB

We use 'references with an arrow function" to link one table model to another table model.

 authorId: uuid().references(() => authorsTable.id).notNull()


 In drizzle.config.js file, we have to mention the schema. But our schema is fragmented into two files i.e., authorMode.js and bookModel.js. So, here are two ways:
 1. we can just mention the main directory of the files i.e., models. -> not tried, so not sure which was told in the course.
 2. We can create an index.js file inside the models folder, and we can import both the authorMode.js and bookModel.js, and use that as file for schema.


 After all these steps, now we must initiate the docker that is, turn on the database by typing "docker compose up -d". Then we have to push the tables in the public schema so we need to type "npx drizzle-kit push".  After this has been created, we must type "npx drizzle-kit studio". Now you will get a link that is https://local.drizzle.studio


 Then you wll see the tables in the link. You can also add data in the drizzle link by selectinng the table or model, and then clicking "Add Record" button.  


 Video - 52
 -----------
Migrating Book Store to Drizzle ORM - Part 2


I have created a copy of book.controller.js as bookCopy.controller.js, and have kept the old code untouched. It helps in comparision between old and new code.


 if (isNaN(id)) {
    return res.status(400).json({ error: `Id must be of type number` });
  }
  This condition will be removed in the new code because uuid will be used as id is not a string. 

  Instead of writing Book((e) => books.id === e.id,  ere we write or use eqyal that is eq which must be imported from drizzle-orm.)


  We need to use const [book]  as book inside an array which is called as array destructing because the db returns an array, and we only need one/first part of it that is id(first part).


  So when should we use [variable]?

ðŸ‘‰ When you expect ONE result from an array

Common cases:

âœ… limit(1) queries
âœ… find first record
âœ… unique ID search
âœ… login user lookup
âœ… checking existence



When NOT to use [ ]

When you expect multiple rows:

const books = await db.select().from(booksTable);

Because you want full list.

Why ORMs always return arrays

Because SQL SELECT can return multiple rows â€” ORM keeps return type consistent.





In createBook, we donot need to return author as in old code. We need to return the authorId. 

 if (!author || author === "") {
    return res.status(400).json({ error: `Author is required` });
  }

  const id = BOOKS.length + 1;

  const book = { id, title, author };
  BOOKS.push(book);

  So wew ill be removing the above code, and typing a new code for inserting into the db whch can be viewed in the code. 


  In createBooks, we need to return id because:
  âœ… 4 â€” Best practice in REST APIs

Standard pattern:

POST â†’ return created resource or id


ðŸ† Real industry rule of thumb

ðŸ‘‰ POST APIs usually return created id or object

So .returning() is very common.

ðŸ”¥ Simple analogy

Imagine submitting a form at office.

Without returning â†’ you drop form and leave

With returning â†’ you get receipt number

That receipt number = id



const [result] = await db.insert(booksTable).values({title, description, authorId}).returning({id: booksTable.id,});


ðŸ“Š Mental model

Database always returns:

ðŸ‘‰ Table (rows) â†’ Array

We pick first row â†’ [row]

ðŸ† One-line takeaway

âœ… Yes â€” we are grabbing the first element from the array returned by the insert query



Syntax of delete and getbyid are differenet. So i asked is it differenet?

Great question ðŸ‘ â€” youâ€™re comparing two different query styles and wondering if theyâ€™re interchangeable.

Short answer:

ðŸ‘‰ They are NOT interchangeable
ðŸ‘‰ They are used for DIFFERENT operations
ðŸ‘‰ Syntax difference is because of how Drizzle API works




| Operation | Syntax             | Why                    |
| --------- | ------------------ | ---------------------- |
| SELECT    | `.select().from()` | Need to specify source |
| DELETE    | `.delete(table)`   | Table already provided |
| INSERT    | `.insert(table)`   | Table already provided |
| UPDATE    | `.update(table)`   | Table already provided |



â­ Industry style recommendation

Most developers prefer:

.where(eq(booksTable.id, id))




Video - 53
-------------
Testing your REST APIs in POSTMAN



We must create a collection named Book STore as we can store all the routes within it.
Then instaed of typing http://localhost:800 for the routes every time, we can create an environment, and there we can assign any name we want which we have assigned as BASE_URl here, and we can assign the link next to it, and we can set the environment as the created env name, and then use BAE_URL along with the links. 




Video - 54
-----------
Using Indexes in PostgresSQL to speed up queries


Now we have to add a route for search, where we can search for books. So, we need a search functionality.

So instead of im,plementing search functionality, we can do something. In get all books, {{BASE_URL}/books?search=node}  -  we can add or do something like this is query parameter where we need tro search a node books in the title of the books(just a example name of the book named book). When we search in get all books route, the result must appear. 


so if i add this search in getAllBooks routes function,
exports.getAllBooks = async function (req, res) {
  const search = req.query.search;
  console.log({ search });
  const books = await db.select().from(booksTable);
  return res.json(books);
};

and, add {{BASE_URL}}/books?search=node as route, then we will get the console.log output as:
{ search: 'node' }.  
Now, if i remove ?search=node in url, then i will get {search: 'undefined' }. Now, we got to klnow that we have to add some logic to search here, and it works. 


Now we need to add a condition for search and would do the same await function, but we need to import "ilike" from drizzle-orm. 

ILike - we can basically give a regex kind of an expression, and I means ignore case. 


exports.getAllBooks = async function (req, res) {
  const search = req.query.search;

  if (search) {
    await db.select().from(booksTable).where(ilike(booksTable.title, `%${search}%`))
  }

  console.log({ search });
  const books = await db.select().from(booksTable);
  return res.json(books);
};

  this is the condition where i in ilike means, ignore small or capital letter of the value which we are searching, and the capital opr amll letters hold the same value meaning. Example, N and n are considered same. So, 'i' means, Ignore Case.

  `%${search}%`  -  anything can be in front of it or back of it, it will search the search value.
  
   

Even, we can write like this which is a professional way used by developers(given by chatgpt):

exports.getAllBooks = async (req, res) => {
  const { search } = req.query;

  const books = search
    ? await db.select().from(booksTable).where(ilike(booksTable.title, `%${search}%`))
    : await db.select().from(booksTable);

  return res.json(books);
};



The below code is used in the course:


exports.getAllBooks = async function (req, res) {
  const search = req.query.search;

  if (search) {
    const books = await db
      .select()
      .from(booksTable)
      .where(ilike(booksTable.title, `%${search}%`));

    return res.json(books);
  }

  console.log({ search });
  const books = await db.select().from(booksTable);
  return res.json(books);
};


But these are time consuming when there are millions of data in the database. Here comes the Indexes to resolve this. We can actually put up a search index on it. 
Now go back to booksTable, and add an extra function at the end where we write an arrow function on the table, and we have to put a search index on the book title. Also. donot forget to import the index at the top. 

After channging this, we need to push th changes to the schema. So, we need to do npx drizzle-kit push. 

const booksTable = pgTable(
  "books",
  {
    id: uuid().primaryKey().defaultRandom(),
    title: varchar({ length: 100 }).notNull(),
    description: text().notNull(),
    authorId: uuid()
      .references(() => authorsTable.id)
      .notNull(),
  },
  (table) => ({
    searchIndexOnTitle: index("title_index").using(
      "gin",
      sql`to_tsvector('english', ${table.title})`,
    ),
  }),
);

this is what we changed in booksTable. The syntax for index search was found in official drizzle-orm search index docs. 
https://orm.drizzle.team/docs/guides/postgresql-full-text-search
I have pasted the link above. 
Also, tjhere was sql import missing in the docs. So i have done that manually.

After doing these, we have to push our schema to the db. Now, we have to do npx drizzle-kit push. 


Now in book.controllers module, instead of using ilike and having a slower performance:

exports.getAllBooks = async function (req, res) {
  const search = req.query.search;

  if (search) {
    const books = await db
      .select()
      .from(booksTable)
      .where(ilike(booksTable.title, `%${search}%`));

    return res.json(books);
  }

  console.log({ search });
  const books = await db.select().from(booksTable);
  return res.json(books);
};



we will use the syntax given in the docs like:

exports.getAllBooks = async function (req, res) {
  const search = req.query.search;

  if (search) {
    const books = await db
      .select()
      .from(booksTable)
      .where(
        sql`to_tsvector('english', ${booksTable.title}) @@ to_tsquery('english', ${search})`,
      );

    return res.json(books);
  }

  console.log({ search });
  const books = await db.select().from(booksTable);
  return res.json(books);
};



After doing this, if you search for something like:   {{BASE_URL}}/books?search=Chiraag   in the postman, you will see that the search time has been decreased. 

These kind of indexing are important when you do sorting, or filtering.



----------------------------------------

Video - 55
-----------
Adding Foreign Key Relationships: Authors and Books


In this video, let us add the Author Routes as well.


Create an filer for Author Routes and controllers file for authors as well. 

I have created routes for all, and the logic in controlers. But the delete logic is not easy beacuse if i delete the author, then I have to delete all the books related o that author as well. 

Now, we need to register this particular rute. We can register it by importing it in main index.js file. 
We have done the same for book routes as well in index.js.
This is the first step.

We will come back to delete after a while.

We can also create a route to get all the books of an author. We msut do it in author.controller.js .
I have created the routes which can be checked in the code. /authors/:id/books - now if type this link, i will get the books related to the author.


Similarly, when i search book by id, i need to get the author details of that book not only the author id. So, go to book.controller.js, import the authorsTable model, and add join in getBookById function. 

exports.getBookById = async function (req, res) {
  const id = req.params.id;
  const [book] = await db
    .select()
    .from(booksTable)
    .where((table) => eq(table.id, id))
    .leftJoin(authorsTable, eq(booksTable.authorId, authorsTable.authorId))
    .limit(1);

Now, you can see, you will get the authors details attached to tha particular author id's book.
THis is a foreign relationship. 


----------------------------------------------


