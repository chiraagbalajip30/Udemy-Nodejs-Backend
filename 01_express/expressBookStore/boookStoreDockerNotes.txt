Video - 51
------------
Migrating Book Store to Drizzle ORM - Part 1: Schema Setup


Firstly, we need to create a docker-compose.yml file. 
Talking about ports in .yml file, we can set it as 5431 but the defaut must be -542:5432. So., it's better to delete the old containers running on that port in docker(previous video is running on this port so delete it).

Chatgpt Content:
-----------------
image in docker-compose.yml file:

instead of installing:
PostgreSQL,
Dependencies,
OS libraries,
Configuration,
Docker just pulls the image which already contains everything.



Why do we need Drizzle-kit?

Why do we need drizzle-kit?

Remember ‚Äî in Drizzle you define tables in code like:

pgTable("users", {...})

But writing schema in code alone does NOT create tables in the database.

üëâ You still need to update the actual database.

That‚Äôs where drizzle-kit comes in.

What drizzle-kit does in simple words

üëâ It converts your schema code ‚Üí SQL migration files
üëâ Then applies those migrations to your database

So, users creates a schema, then it calls dizzle-generate, and then drizzle-migration, and then npx drizzle-kit push.


Course Content:
Then, we installed npm i dotenv, npm i drizzle-orm pg, and npm i drizzle-kit.
Now , all the packages are installed. 


Setup everything that is files. Schema.js is created inside models folder, and is renamed as book.model.js.

// These kind of Foreign-Table relationships are not possible in MongoDB

We use 'references with an arrow function" to link one table model to another table model.

 authorId: uuid().references(() => authorsTable.id).notNull()


 In drizzle.config.js file, we have to mention the schema. But our schema is fragmented into two files i.e., authorMode.js and bookModel.js. So, here are two ways:
 1. we can just mention the main directory of the files i.e., models. -> not tried, so not sure which was told in the course.
 2. We can create an index.js file inside the models folder, and we can import both the authorMode.js and bookModel.js, and use that as file for schema.


 After all these steps, now we must initiate the docker that is, turn on the database by typing "docker compose up -d". Then we have to push the tables in the public schema so we need to type "npx drizzle-kit push".  After this has been created, we must type "npx drizzle-kit studio". Now you will get a link that is https://local.drizzle.studio


 Then you wll see the tables in the link. You can also add data in the drizzle link by selectinng the table or model, and then clicking "Add Record" button.  


 Video - 52
 -----------
Migrating Book Store to Drizzle ORM - Part 2


I have created a copy of book.controller.js as bookCopy.controller.js, and have kept the old code untouched. It helps in comparision between old and new code.


 if (isNaN(id)) {
    return res.status(400).json({ error: `Id must be of type number` });
  }
  This condition will be removed in the new code because uuid will be used as id is not a string. 

  Instead of writing Book((e) => books.id === e.id,  ere we write or use eqyal that is eq which must be imported from drizzle-orm.)


  We need to use const [book]  as book inside an array which is called as array destructing because the db returns an array, and we only need one/first part of it that is id(first part).


  So when should we use [variable]?

üëâ When you expect ONE result from an array

Common cases:

‚úÖ limit(1) queries
‚úÖ find first record
‚úÖ unique ID search
‚úÖ login user lookup
‚úÖ checking existence



When NOT to use [ ]

When you expect multiple rows:

const books = await db.select().from(booksTable);

Because you want full list.

Why ORMs always return arrays

Because SQL SELECT can return multiple rows ‚Äî ORM keeps return type consistent.





In createBook, we donot need to return author as in old code. We need to return the authorId. 

 if (!author || author === "") {
    return res.status(400).json({ error: `Author is required` });
  }

  const id = BOOKS.length + 1;

  const book = { id, title, author };
  BOOKS.push(book);

  So wew ill be removing the above code, and typing a new code for inserting into the db whch can be viewed in the code. 


  In createBooks, we need to return id because:
  ‚úÖ 4 ‚Äî Best practice in REST APIs

Standard pattern:

POST ‚Üí return created resource or id


üèÜ Real industry rule of thumb

üëâ POST APIs usually return created id or object

So .returning() is very common.

üî• Simple analogy

Imagine submitting a form at office.

Without returning ‚Üí you drop form and leave

With returning ‚Üí you get receipt number

That receipt number = id



const [result] = await db.insert(booksTable).values({title, description, authorId}).returning({id: booksTable.id,});


üìä Mental model

Database always returns:

üëâ Table (rows) ‚Üí Array

We pick first row ‚Üí [row]

üèÜ One-line takeaway

‚úÖ Yes ‚Äî we are grabbing the first element from the array returned by the insert query



Syntax of delete and getbyid are differenet. So i asked is it differenet?

Great question üëç ‚Äî you‚Äôre comparing two different query styles and wondering if they‚Äôre interchangeable.

Short answer:

üëâ They are NOT interchangeable
üëâ They are used for DIFFERENT operations
üëâ Syntax difference is because of how Drizzle API works




| Operation | Syntax             | Why                    |
| --------- | ------------------ | ---------------------- |
| SELECT    | `.select().from()` | Need to specify source |
| DELETE    | `.delete(table)`   | Table already provided |
| INSERT    | `.insert(table)`   | Table already provided |
| UPDATE    | `.update(table)`   | Table already provided |



‚≠ê Industry style recommendation

Most developers prefer:

.where(eq(booksTable.id, id))




Video - 53
-------------
Testing your REST APIs in POSTMAN



We must create a collection named Book STore as we can store all the routes within it.
Then instaed of typing http://localhost:800 for the routes every time, we can create an environment, and there we can assign any name we want which we have assigned as BASE_URl here, and we can assign the link next to it, and we can set the environment as the created env name, and then use BAE_URL along with the links. 




Video - 54
-----------
Using Indexes in PostgresSQL to speed up queries


Now we have to add a route for search, where we can search for books. So, we need a search functionality.

So instead of im,plementing search functionality, we can do something. In get all books, {{BASE_URL}/books?search=node}  -  we can add or do something like this is query parameter where we need tro search a node books in the title of the books(just a example name of the book named book). When we search in get all books route, the result must appear. 


so if i add this search in getAllBooks routes function,
exports.getAllBooks = async function (req, res) {
  const search = req.query.search;
  console.log({ search });
  const books = await db.select().from(booksTable);
  return res.json(books);
};

and, add {{BASE_URL}}/books?search=node as route, then we will get the console.log output as:
{ search: 'node' }.  
Now, if i remove ?search=node in url, then i will get {search: 'undefined' }. Now, we got to klnow that we have to add some logic to search here, and it works. 


Now we need to add a condition for search and would do the same await function, but we need to import "ilike" from drizzle-orm. 

ILike - we can basically give a regex kind of an expression, and I means ignore case. 


exports.getAllBooks = async function (req, res) {
  const search = req.query.search;

  if (search) {
    await db.select().from(booksTable).where(ilike(booksTable.title, `%${search}%`))
  }

  console.log({ search });
  const books = await db.select().from(booksTable);
  return res.json(books);
};

  this is the condition where i in ilike means, ignore small or capital letter of the value which we are searching, and the capital opr amll letters hold the same value meaning. Example, N and n are considered same. So, 'i' means, Ignore Case.

  `%${search}%`  -  anything can be in front of it or back of it, it will search the search value.
  
   

Even, we can write like this which is a professional way used by developers(given by chatgpt):

exports.getAllBooks = async (req, res) => {
  const { search } = req.query;

  const books = search
    ? await db.select().from(booksTable).where(ilike(booksTable.title, `%${search}%`))
    : await db.select().from(booksTable);

  return res.json(books);
};



The below code is used in the course:


exports.getAllBooks = async function (req, res) {
  const search = req.query.search;

  if (search) {
    const books = await db
      .select()
      .from(booksTable)
      .where(ilike(booksTable.title, `%${search}%`));

    return res.json(books);
  }

  console.log({ search });
  const books = await db.select().from(booksTable);
  return res.json(books);
};


But these are time consuming when there are millions of data in the database. Here comes the Indexes to resolve this. We can actually put up a search index on it. 
Now go back to booksTable, and add an extra function at the end where we write an arrow function on the table, and we have to put a search index on the book title. Also. donot forget to import the index at the top. 

After channging this, we need to push th changes to the schema. So, we need to do npx drizzle-kit push. 

const booksTable = pgTable(
  "books",
  {
    id: uuid().primaryKey().defaultRandom(),
    title: varchar({ length: 100 }).notNull(),
    description: text().notNull(),
    authorId: uuid()
      .references(() => authorsTable.id)
      .notNull(),
  },
  (table) => ({
    searchIndexOnTitle: index("title_index").using(
      "gin",
      sql`to_tsvector('english', ${table.title})`,
    ),
  }),
);

this is what we changed in booksTable. The syntax for index search was found in official drizzle-orm search index docs. 
https://orm.drizzle.team/docs/guides/postgresql-full-text-search
I have pasted the link above. 
Also, tjhere was sql import missing in the docs. So i have done that manually.

After doing these, we have to push our schema to the db. Now, we have to do npx drizzle-kit push. 


Now in book.controllers module, instead of using ilike and having a slower performance:

exports.getAllBooks = async function (req, res) {
  const search = req.query.search;

  if (search) {
    const books = await db
      .select()
      .from(booksTable)
      .where(ilike(booksTable.title, `%${search}%`));

    return res.json(books);
  }

  console.log({ search });
  const books = await db.select().from(booksTable);
  return res.json(books);
};



we will use the syntax given in the docs like:

exports.getAllBooks = async function (req, res) {
  const search = req.query.search;

  if (search) {
    const books = await db
      .select()
      .from(booksTable)
      .where(
        sql`to_tsvector('english', ${booksTable.title}) @@ to_tsquery('english', ${search})`,
      );

    return res.json(books);
  }

  console.log({ search });
  const books = await db.select().from(booksTable);
  return res.json(books);
};



After doing this, if you search for something like:   {{BASE_URL}}/books?search=Chiraag   in the postman, you will see that the search time has been decreased. 

These kind of indexing are important when you do sorting, or filtering.



----------------------------------------

Video - 55
-----------
Adding Foreign Key Relationships: Authors and Books


In this video, let us add the Author Routes as well.


Create an filer for Author Routes and controllers file for authors as well. 

I have created routes for all, and the logic in controlers. But the delete logic is not easy beacuse if i delete the author, then I have to delete all the books related o that author as well. 

Now, we need to register this particular rute. We can register it by importing it in main index.js file. 
We have done the same for book routes as well in index.js.
This is the first step.

We will come back to delete after a while.

We can also create a route to get all the books of an author. We msut do it in author.controller.js .
I have created the routes which can be checked in the code. /authors/:id/books - now if type this link, i will get the books related to the author.


Similarly, when i search book by id, i need to get the author details of that book not only the author id. So, go to book.controller.js, import the authorsTable model, and add join in getBookById function. 

exports.getBookById = async function (req, res) {
  const id = req.params.id;
  const [book] = await db
    .select()
    .from(booksTable)
    .where((table) => eq(table.id, id))
    .leftJoin(authorsTable, eq(booksTable.authorId, authorsTable.authorId))
    .limit(1);
}

Now, you can see, you will get the authors details attached to tha particular author id's book.
THis is a foreign relationship. 


----------------------------------------------

Video - 56
-----------
Understanding Authorization vs Authentication with Real-World Examples



Authentication:

It means "who are you?".


Authorization:

It is the next step of Authentication. 

The main challenge lies in Authentication. If this is surpassed, then Authorization becomes easyas it is just a check. 

----------------------------------------------


Video - 57
-----------
What is Authentication? A Story-Based Introduction to Login Systems.


We will understand Authentication with a story.

We will take a parking lot. Let us say it is a paid and reserved service taken by some xyz company for their own purpose.
They have a security guard. No one have access to park the car there(random people). 
Now let us say, it is a vallet parking. Now, the owner comes and parks the car. Before parking, the security guard comes and takes the car, and he parks the car in the empty space. Then he gives a token by mentioning your car name so that you can show this card to take back your car when you want to. 
Security guard has a diary,and he stores the car number belomgs to so and so token number. 
Once the owner comes back, he will give the token number, security guard opens the diary and checks if the token number matches the car number, and he then parks the car outside and handovers the key to the owner. 
The main thing is that token is being issued here. 
There also might be a probelm. Let  us say, there will be 200 cars. If there is one security guard, he will be tired, and must look at the cars one by one, and the 200 people have to wait in the long queue. 
So, what i can do is increase the resource that is, security guards. So i will make three lines, and divide the traffic into three lines parallely. Now, the speed is faster as well. 
There is a problem as well in this approach. There is only one diary. When one security guard is writing down in that diary, the others in the queue have to wait. 
So, now we will increase the numbewr of diaries. Now we think everything is good. 
But there is a problem. If a car goes to one security guard and gets his vehickle number entered in one diary, and when he comes back if he goes to the another security guard, he won't be having that token in his diary. 
Next idea is one security guard with multiple diaries. Pro is the above problem is solved that is, customers must come to the same security guard, and no need of remembering to whom they gave the cvar. COns is one security guard casnnot hasndle the queue, while other security guards will be idling sitting with no queue. 
SO, three approaches are done. Both have their own pros and cons.


The same happens in the authentication of server sas well. 
First we will try, One server, One state(tokens). So we will end up in case-1 problem. The same for other cases.
This was just an example. 
In the next video, we will try all the cases, and then come too the final correct option which will be shown in the next video.

Chatgpt:
---------
load balancer is a system that distributes incoming traffic across multiple servers so no single server gets overwhelmed.

üîÑ What It Does

When users visit your website:

The request first goes to the load balancer

The load balancer chooses a server

It forwards the request to that server

The server responds to the user



üéØ Why It‚Äôs Important
‚úÖ Prevents Overload

Spreads traffic evenly so no single server crashes.

‚úÖ High Availability

If one server fails, traffic is automatically sent to healthy servers.

‚úÖ Improves Performance

Users experience faster response times.

‚úÖ Enables Horizontal Scaling

Essential when running multiple servers.



üß† How It Decides Where to Send Traffic

Common algorithms:

Round Robin ‚Üí Takes turns between servers

Least Connections ‚Üí Sends traffic to the least busy server

IP Hash ‚Üí Same user goes to the same server

Weighted Distribution ‚Üí More powerful servers get more traffic



üèó Types of Load Balancers
1Ô∏è‚É£ Hardware Load Balancers

Physical devices in data centers.

2Ô∏è‚É£ Software Load Balancers

Run as applications or services.

Examples:

NGINX

HAProxy

Apache HTTP Server

3Ô∏è‚É£ Cloud Load Balancers

Managed services from cloud providers:

Amazon Web Services Elastic Load Balancer

Google Cloud Load Balancing

Microsoft Azure Load Balancer



üè¢ Simple Real-World Analogy

Imagine a restaurant host:

Customers walk in

The host assigns them to available tables

If one waiter is busy, customers go to another

The host = load balancer
The waiters = servers



-----------------------------------------------


Video - 58
-----------
Implementing Session-Based Authentication in Node.js Applications













